% labels and refs added
% grammar for 'SYSTEM' added
% signals in put/get formats added; behavior clearified

\chapter{Input and Output}   % 10

The input and output statements enable the transfer of data from the
working memory of the computer to an external data station (output) and
vice versa, the transfer of data from an external data station to the
working memory (input). Primarily, data stations are standard peripheral
devices (printer, console, disk, magnetic tape, keyboard, etc.) or
process peripherals (sensors, actuators, embedded controllers, etc.).

On these {\em system defined} data stations, {\em user defined} data
stations can be created in the program to store data, e.g., on disks,
magnetic tapes, printers, etc.

In the I/O statements of the problem part, the data stations are
addressed under freely selectable, logical user names; the features of
the data stations are to be specified before mentioning these names.

In conventional programming languages, the association of the logical
identifiers (user names) for data stations used in the program to the
devices of a particular computer system is done by additional control
definitions when setting up a compiler program (job control
definitions). In PEARL, these associations take place in standardised
notation by declarations in the system part.

\section{System Part}    % 10.1
\label{dation_system_part}

The system part serves for describing the used I/O configurations of a
PEARL program. A system name must be associated with all devices of a
computer system which can directly be addressed with PEARL I/O
statements. A list of these devices and their system names can be
found in the PEARL user manual of the corresponding target system. In
the system part, freely selectable user names must be assigned to the
system names of the needed devices. The devices can only be addressed in
I/O statements of the problem part via these user names. If there are
several devices of the same type, they can also be distinguished by an
index added to the system name. Thus, a system name has the following
general form:

\begin{removed}
SystemName ::=\\
\x Identifier [ (nni$\S $index) ]

nni ::=\\
\x IntegerWithoutPrecision$\S $NonNegative

For most of the process devices, further details are necessary, such as
the channel number, and for digital I/O channels, even the selection of
single bits can be desired. Thus, the following extension after the
system name is possible for process devices:

ExtensionProcessDevice ::=\\
\x $^*$nni$\S $ChannelNumber [ $^*$nni$\S $Position [ , nni$\S $Width ] ]

With ``Position'', e.g., the initial bit position of the device
connection of a digital input/output, with ``Width'', the number of bits
of this device connection can be given.

Thus, a system part consists of a number of device associations of the
following form:

DeviceAssociation ::=\\
\x UserName: SystemName [ ExtensionProcessDevice ]

UserName ::=\\
\x Identifier

For the example of a system part as given below, a fictive computer
system with the following system names is assumed:

\begin{tabular}{l@{\x}l}
SystemName & Device \\ \hline
STDIN      & standard input (console) \\
STDOUT     & standard output (console) \\
SERIAL     & for I/O with serial interfaces \\
DISC       & for reading and writing files (disk, floppy,...)\\
DIGIO      & digital I/O\\
\end{tabular}

PEARL example for the system part:

\begin{tabbing}
\x dateout: \= \kill
{\bf MODULE} (example); \> \\
{\bf SYSTEM}; \> \\
\x termin:  \> STDIN; \\
\x termout: \> STDOUT;\\
\x file:    \> DISC;  \\
\x tty\_1:  \> SERIAL(1);\\
\x tty\_4:  \> SERIAL(4);\\
\x counter: \> DIGIO$^*$0; \\
\x switch:  \> DIGIO$^*$1$^*$16,1; \\
\x motor:   \> DIGIO$^*$1$^*$1,4;  \\
\x ... \> \\
{\bf PROBLEM};\> \\
\x ... \>
\end{tabbing}
\end{removed}

\begin{added}
SystemName ::=\\
\x Identifier$\S $SystemDationName [ (Constant$\S $Parameter [, Constant$\S $Parameter]...) ]

For the example of a system part as given below, a typicla linux computer
system with the following system names defined by OpenPEARL:

\begin{tabular}{ll@{\x}p{6cm}}
SystemName & Parameter & Device \\ \hline
StdStream  &  0 & standard input \\
StdStream  &  1 & standard output \\
Disc       & '/home', 10 & files for reading and writing are located in the given folder. The maximum of concurrent open files also specified. \\
OctopusDigIn & ... & Digital input: Details are described in the plattform users guide \\
OctopusDigOut & ... & Digital output: Details are described in the plattform users guide \\
\end{tabular}

PEARL example for the system part:

\begin{tabbing}
\x dateout: \= \kill
{\bf MODULE} (example); \> \\
{\bf SYSTEM}; \> \\
\x termin:  \> StdStream(0); \\
\x termout: \> StdStream(1);\\
\x file:    \> Disc('/tmp' ,10) ;  \\
\x counter: \> OctopusDigitalIn('A',3,1); \\
\x switch:  \> OctopusDigitalOut('B',3,1); \\
\x motor:   \> OctopusDigitalOut('B',7,4); \\
\x ... \> \\
{\bf PROBLEM};\> \\
\x ... \>
\end{tabbing}

\end{added}

The available devices and the associated system names must be taken from
the corresponding user manual of a PEARL implementation. There it is
also described, whether (and, if yes, how) system names can be changed.
For most PEARL systems there is an additional possibility to integrate
device drivers and their system names created by the user into the PEARL
system and to address them with PEARL I/O statements.

\section{Specification and Declaration of Data Stations (DATION) in 
the Problem Part}   % 10.2
\label{sec_dation_problem_part}

\subsection{System Data Stations}   % 10.2.1

Before using system defined data stations, they must be specified in the
problem part, defining their associated user names. 
\addedtext{The class attribute {\bf SYSTEM} must be set in the
specification statement}.
For the declarations from the above example, this can take place as:

\begin{removed}
\begin{tabular}{llll}
{\bf SPC} & termin  & {\bf DATION IN}    & {\bf ALPHIC},\\
   & termout & {\bf DATION OUT}   & {\bf ALPHIC},\\
   & file    & {\bf DATION INOUT} & {\bf ALL},   \\
   & tty\_1  & {\bf DATION IN}    & {\bf ALPHIC},\\
   & tty\_4  & {\bf DATION INOUT} & {\bf ALL},   \\
   & counter & {\bf DATION IN}    & {\bf BASIC}, \\
   & switch  & {\bf DATION OUT}   & {\bf BASIC}, \\
   & motor   & {\bf DATION OUT}   & {\bf BASIC}; \\
\end{tabular}
\end{removed}
\begin{added}
\begin{tabular}{llll}
{\bf SPC} & termin  & {\bf DATION IN}    & {\bf SYSTEM ALL},\\
   & termout & {\bf DATION OUT}   & {\bf SYSTEM ALL},\\
   & file    & {\bf DATION INOUT} & {\bf SYSTEM ALL},   \\
   & tty\_1  & {\bf DATION IN}    & {\bf SYSTEM ALL},\\
   & tty\_4  & {\bf DATION INOUT} & {\bf SYSTEM ALL},   \\
   & counter & {\bf DATION IN}    & {\bf SYSTEM BIT(1)}, \\
   & switch  & {\bf DATION OUT}   & {\bf SYSTEM BIT(1)}, \\
   & motor   & {\bf DATION OUT}   & {\bf SYSTEM BIT(4)}; \\
\end{tabular}
\end{added}

The general form reads:

DationSpecification ::= \\
\x \{ {\bf SPECIFY $\mid$ SPC} \} IdentifierDenotation TypeDation [ GlobalAttribute ] ;

The different attributes in a system dation specification describe the
fundamental features of the physical device to be communicated with. The
features of a device and the possible attributes are described for all
devices in the user manual.

\subsection{User Defined Data Stations}    % 10.2.2

By a dation declaration, a logical, so-called user defined data station
(or user dation) is created on a physical device (system dation). The
allocation to a device is determined by the CREATED attribute.

All input/output statements described in the following refer to user
dations --- the direct declaration of system dations leads to run time
errors.

DationDeclaration ::= \\
\x \{{\bf DECLARE $\mid$ DCL}\} IdentifierDenotation TypeDation [GlobalAttribute]\\
\x {\bf CREATED} (Name$\S $SystemDefDation);

Hence, no arrays of data stations may be declared. However, it is
possible to declare arrays of references to data stations to enable also
indexed addressing of data stations.

The various attributes enable the detection of contradictions between
the features of data stations and their way of using in I/O statements
already at compilation time.

TypeDation ::= \\
\x {\bf DATION} SourceSinkAttribute ClassAttribute\\
\x [ Structure ] [ AccessAttribute ]

Each data station is source and/or sink of a data transmission. The
corresponding feature must be given upon declaration:

SourceSinkAttribute ::= \\
\x {\bf IN $\mid$ OUT $\mid$ INOUT}

IN means that this data station is a source for data, i.e., it may only
appear in such data transmission statements which transmit these data
{\em into} the working memory (e.g., digital inputs, keyboard).

Data stations specified with OUT may only be used as sinks for outputs
from the working memory (e.g., printer).

A data station with attribute INOUT allows for data transmissions in
both directions (e.g., disk).

The data transmissions take place with the computer internal format of
the data or by means of conversion between computer internal and
external format. For this, PEARL provides three different kinds of I/O
statements:
\begin{itemize}
\item The READ/WRITE statements for transmission in computer internal
format (e.g., for disk data, see \ref{sec_read_write}).
\item The PUT/GET statements for transmission with conversion between
internal format and representation in the character set available on the
data station (e.g., for printer output, see \ref{sec_get_put}).
\item The TAKE/SEND statements for transmitting process data (see
\ref{sec_take_send}).
\end{itemize}

The data transmission to or from a data station can only take place in
one of the given ways.

The selection is made when declaring the data station by means of the
class attribute stating to which of the three classes the data belong:
\begin{itemize}
\item If the READ/WRITE statements are to be used, i.e., if the data
station records data in computer internal form, the type of data to be
transmitted is stated as class attribute, e.g., FIXED, or FLOAT (53),
or BIT (16), or ALL (for various types).
\item If the data are represented alphanumerically on the data stations
(case PUT/GET), the data station gets the class attribute ALPHIC.
\item Data stations for transmissions with the TAKE/SEND statements
have class attribute BASIC.
\end{itemize}

The general form of the class attribute reads:

\begin{removed}
ClassAttribute ::= \\
\x {\bf ALPHIC $\mid$ BASIC} $\mid$ TypeOfTransmissionData
\end{removed}
\begin{added}
ClassAttribute ::= \\
\x [ {\bf SYSTEM} ]  /* system dation */\\
\x \x {\bf ALPHIC} $\mid$                  /* PUT/GET */ \\
\x \x {\bf BASIC}  TypeOfTransmissionData $\mid$  /* TAKE/SEND */\\
\x \x  TypeOfTransmissionData               /* READ/WRITE */ \\
\end{added}

TypeOfTransmissionData ::=\\
\x {\bf ALL} $\mid$ SimpleType $\mid$ CompoundType

SimpleType ::= \\
\x TypeInteger $\mid$ TypeFloatingPointNumber $\mid$ TypeBitString $\mid$\\
\x TypeCharacterString $\mid$ TypeTime $\mid$ TypeDuration

CompoundType ::= \\
\x IO-Structure $\mid$ Identifier$\S $ForNewTypeFromSimpleTypes

IO-Structure ::=\\
\x {\bf STRUCT} [ IO-StructureComponent [ , IO-StructureComponent ] $^{...}$ ]

IO-StructureComponent := \\
\x IdentifierDenotation\\
\x \{ SimpleType $\mid$ IO-Structure $\mid$ Identifier$\S $ForNewTypeFromSimpleTypes \}

Hence, the type of the transmission data may also be a multiply
structured structure or a newly defined type, but no component being of
type reference.

Example:

\begin{tabbing}
{\bf TYPE} \= \kill

...        \> \\
{\bf TYPE} \> Kind\_Structure {\bf STRUCT} \\
    \> {\bf [} (No, Number) {\bf FIXED},\\
    \> \x Weight {\bf FLOAT}, ...{\bf ]};\\
{\bf DCL}  \> Kind\_File {\bf DATION INOUT} Kind\_Structure ...,\\
    \> Tab {\bf DATION INOUT FIXED} ...;
\end{tabbing}

The attribute ALL includes all other possibilities of type of
transmission data.

Example:

On a disk memory drive with system name PSP31 and user name Disk, a file
File1 for the input of FIXED quantities and a file File2 for the
input/output of FLOAT quantities with computer internal format are to be
created.

{\bf SYSTEM};\\
\begin{removed}
\x Disk: PSP31;
{\bf PROBLEM};\\
\x {\bf SPC} Disk {\bf DATION INOUT ALL} ...;\\
\end{removed}
\begin{added}
\x Disk: Disc('/home',10);
{\bf PROBLEM};\\
\x {\bf SPC} Disk {\bf DATION INOUT SYSTEM ALL} ...;\\
\end{added}
\x {\bf DCL} File1 {\bf DATION IN FIXED} ... {\bf CREATED} (Disk);\\
\x {\bf DCL} File2 {\bf DATION INOUT FLOAT} ... {\bf CREATED} (Disk);

The source/sink attribute and the class attribute must be defined for
each data station, in contrast to the now described attributes for the
structure and access possibilities of a data stations.

The smallest data set transmitted to or from a data station is called
data element. Its type is determined by the class attribute. Several
data elements can be combined into a record (synonymously, line), and
several records to a segment (syonymously, page), i.e., all elements
make up a 1-, 2-, or 3-dimensional array. For this, the number of data
elements in a line, the number of lines in a page, and the number of
pages must be denoted in the structure attribute:

Typology ::= \\
\x {\bf DIM} ( \{ $^*$ $\mid$ pi \} [ , pi [ , pi ] ] ) [ {\bf TFU} [ {\bf MAX} ] ]

The pi denotation furthest to the right always denotes the number of
elements per line, the next (possibly lacking) pi denotation denotes
the number of lines per page, and the following (possibly lacking) pi
denotation denotes the number of pages. The denotation $^*$ means that
the corresponding number is not limited. E.g., a data station Printer
with 120 characters per line, 60 lines per page, and any number of pages
can obtain the structure ($^*$, 60, 120).

The following combinations are possible:
\begin{itemize}
\item 3-dimensional typology\\
DIM (number of pages, number of lines, number of elements), or\\
DIM ($^*$, number of lines, number of elements)
\item 2-dimensional typology\\
DIM (number of lines, number of elements), or\\
DIM ($^*$, number of elements)
\item 1-dimensional typology\\
DIM (number of elements), or\\
DIM ($^*$)
\end{itemize}

Furthermore, the typology indicates, how many data elements are
transmitted {\em at least} upon the execution of {\em one} data
transmission statement:
\begin{itemize}
\item If the attributes TFU and MAX are lacking, single data elements,
lines or pages can be transmitted.
\item Attribute TFU means that only lines or pages are transferable.\\
If the actual number of data elements in a data transmission statement
is less than the number of data elements of a line or page, this line or
page, respectively, is implicitly padded with spaces (ALPHIC data
stations) or zeros (BASIC data stations).

Example:

{\bf DCL} Printer {\bf DATION OUT ALPHIC DIM}($^*$, 60, 120) {\bf TFU} ...;\\
... \\
{\bf PUT} 'PEARL' {\bf TO} Printer;

This PUT statement has the effect that the five characters P, E, A, R,
L are written out in one (new) line by Printer.
\item TFU MAX corresponds to TFU.
\end{itemize}

The possible ways of accessing a data station are determined by the
access attribute:

AccessAttribute ::= \\
\x {\bf \{ DIRECT $\mid$ FORWARD $\mid$ FORBACK \} [ NOCYCL $\mid$ CYCLIC ]}\\
\x {\bf [ STREAM $\mid$ NOSTREAM ]}

DIRECT means that (based on a transmitted data element) any data element
can directly be accessed, giving the position of the element
(see \ref{sec_read_write}, \ref{sec_get_put}).

The attributes FORWARD and FORBACK mean sequential access; i.e., the
access may (based on a transmitted element) only take place in the order
determined by the structure --- for FORWARD only forward, for FORBACK in
both directions ---, possibly giving the relative position of the wanted
element to the element just transmitted 
(see \ref{sec_read_write}, \ref{sec_get_put}).

\begin{added}
OpenPEARL does not support FORBACK dations.
\end{added}

NOCYCL, CYCLIC, STREAM, and NOSTREAM are treated in the context of the
I/O statements in 
\ref{sec_read_write} and \ref{sec_get_put}.

Example:

On a disk drive with system name PSP31 and user name Disk a file for a
table with 300 lines and 5 columns (elements per line) is to be created.
Let the table elements be floating point numbers; the access takes place
to elements directly and only reading.

{\bf MODULE};\\

{\bf SYSTEM};\\
\x Disk: PSP31;\\
\x ... \\
\label{Example}
{\bf PROBLEM};\\
\x {\bf SPC} Disk {\bf DATION INOUT \addedtext{SYSTEM} ALL};\\
\x {\bf DCL} Table {\bf DATION IN FLOAT DIM}(300, 5) {\bf DIRECT}\\
\x \x {\bf GLOBAL CREATED} (Disk);\\
\x ...

Examples for the declaration of data stations for inputs/outputs in
character form are described in 
\ref{sec_read_write} and \ref{sec_get_put}.

\begin{added}
The characteristics of the system dation must fit to the specification:
\begin{itemize}
\item ALPHIC specification may be done upon system dations of type ALPHIC,
   ALL or CHAR
\item FORWARD specification is compatible with DIRECT attribute
   of the system dation
\item DIM specifications must not exceed the size of the system dation --- 
   more artificial dimensions may be specified
\item ... (some more items missing??)
\end{itemize}
\end{added}

\section{Opening and Closing of Data Stations (OPEN, CLOSE)}   % 10.3
\label{sec_open_close}

Before a data station may be used for the first time in a data
transmission statement, it must be opened by the open statement:

OpenStatement ::=\\
\x {\bf OPEN} Name$\S $Dation [ {\bf BY} OpenParameter [ , OpenParameter ] $^{...}$ ] ;

When executing the open statement, a data station with typology is
positioned at its beginning.

The open parameters serve to handle data stations containing
identifyable files. E.g., a system defined data station Disk can possess
a file TAB1, which is also maintained after terminating the program
under this name. Later on, the same or another program can create a user
defined data station Table on Disk, identified with file TAB1 in the
open statement.

OpenParameter ::=\\
\x {\bf IDF} ( \{Name$\S $CharacterVariable $\mid$ CharacterStringConstant \} ) $\mid$\\
\x {\bf RST} (Name$\S $ErrorVariable-FIXED) $\mid$ \\
\x \{ {\bf OLD $\mid$ NEW $\mid$ ANY} \} $\mid$ \\
\x \{ {\bf CAN $\mid$ PRM} \}

The open parameters of the open statement must belong to different
subsets.

Meaning of the parameters:
\begin{itemize}
\item IDF (Name$\S $CharacterVariable $\mid$ CharacterStringConstant)\\
The value of the specified character variable or the specified character
string constant is the name of the file to be identified with the data
station named Name$\S $Dation.
\item RST (Name$\S $ErrorVariable-FIXED)\\
If an error occurs during the OPEN execution, the specified variable is
assigned an error number unequal to zero; in the error-free case, it is
set to zero (see \ref{sec_dation_rst}).
\item OLD\\
If there is a file with IDF name, it its allocated on the notated data
station. Otherwise, or if IDF is lacking, an error message is given, or
the RST variable is set with the error number.
\item NEW\\
A file with IDF name is created and identified with the notated data
station. If there is already a file with this name, or if IDF is
lacking, an error message is given, or the RST variable is set with the
error number.
\item ANY\\
If there is already a file with IDF name, it is identified with the
notated data station. Otherwise, a new file is created for it. If IDF
is lacking, a new file is created under a name determined by the system
and identified with the denoted data station.
\item CAN (from ``cancel'')\\
The file is no longer to be made accessible after executing the close
statement (see below).
\item PRM (from ``permanent'')\\
The file is still there after executing the close statement, and again
accessible with the same name after re-executing an open statement.
\end{itemize}

If open parameters are lacking, ANY and PRM are assumed.

When executing the close statement, a file is closed; i.e., it is
usable again not before the execution of an open statement.

CloseStatement ::=\\
\x {\bf CLOSE} Name$\S $Dation [ {\bf BY} CloseParameter [ , CloseParameter ] $^{...}$ ] ;

The settings for closing a data station made in the open statement can
be overwritten by a close statement:

CloseParameter ::=\\
\x {\bf CAN $\mid$ PRM $\mid$ RST} (Name$\S $ErrorVariable-FIXED)

Generally, the following rules hold:
\begin{itemize}
\item Not every task executing an access to a data station must execute
an open or close statement.
\item However, at least one open statement must be executed concerning
the access to a data station.
\item The same number of close statements and open statements must
be executed to close the data station.
\item Corresponding open and close statements need not be executed by
the same task.
\item Upon lacking parameters, ANY and PRM are assumed, unless earlier
executed close or open statements have made explicit settings.
\end{itemize}

Example:

{\bf MODULE};\\
{\bf SYSTEM};\\
\x Printer: DRUA;\\
\x Disk: PSP31;\\
\x ... \\
{\bf PROBLEM};\\
\x {\bf SPC} Printer {\bf DATION OUT \addedtext{SYSTEM} ALPHIC};\\
\x {\bf DCL} Tab\_Prot {\bf DATION OUT ALPHIC DIM}($^*$, 50, 30) {\bf FORWARD}\\
\x \x {\bf GLOBAL CREATED}(Printer);\\
\x {\bf SPC} Disk {\bf DATION INOUT \addedtext{SYSTEM} ALL};\\
\x {\bf DCL} Table {\bf DATION IN FLOAT DIM}(300, 5) {\bf DIRECT}\\
\x \x {\bf GLOBAL CREATED}(Disk);

Start: {\bf TASK MAIN};\\
\x {\bf OPEN} Tab\_Prot;\\
\x {\bf OPEN} Table {\bf BY} IDF('TAB-1'), OLD;\\
\x {\bf ACTIVATE} Prot;\\
\x ...\\
\x {\bf END}; ! Start

Prot: {\bf TASK};\\
\x ! Data transmission statements with Table and Tab\_Prot\\
\x ...\\
\x {\bf CLOSE} Tab\_Prot;\\
\x {\bf CLOSE} Table; \\
\x {\bf END}; ! Prot \\
... \\
{\bf MODEND};

\section{The Read and Write Statements (READ, WRITE)}   % 10.4
\label{sec_read_write}

The read statement serves for the input, the write statement for the
output of data without converting the computer internal representation
(binary input/output). Data can be transmitted to or from the connected
devices (e.g., a file on disk or magnetic tape). The corresponding data
stations must be declared with the class attribute
``TypeOfTransmissionData''.

Examples:

\begin{enumerate}
\item Columns 4 and 5 in the dation Table (cf. the example on page
\pageref{Example}) are to be replaced by re-calculated values.

...\\
{\bf DCL} (x, y, z) {\bf FLOAT};\\
...\\
{\bf FOR} line {\bf FROM} 1 {\bf TO} 300\\
{\bf REPEAT}\\
\x ! calculation of x, y, z\\
\x {\bf WRITE} x, SIN(y+z) {\bf TO} Table {\bf BY POS}(line, 4);\\
{\bf END};

\item A task Measurement periodically acquires 14 temperature values
(Procedure Get\_Temp), processes them, and writes them sequentially in
blocks with 14 values in a logbook on the disk.

{\bf SYSTEM};\\
\x File: DISC;

{\bf PROBLEM};\\
\x {\bf SPC} Get\_Temp {\bf PROC}(i {\bf FIXED}) {\bf RETURNS} ({\bf FIXED}(15)) {\bf GLOBAL};\\
\x {\bf SPC} File {\bf DATION INOUT \addedtext{SYSTEM} ALL};\\
\x {\bf DCL} Logbook {\bf DATION OUT FIXED}(15) {\bf DIM}($^*$, 14) {\bf TFU FORWARD}\\
\x \x {\bf CREATED} (File);\\
\x {\bf DCL} Num\_Temp {\bf INV FIXED}(15) {\bf INIT}(14);

Start: {\bf TASK MAIN};\\
\x {\bf OPEN} Logbook; \x ! Positioning to beginning\\
\x {\bf ALL} 10 {\bf SEC ACTIVATE} Measurement;\\
\x ... \\
\x {\bf END}; ! Start

Measurement: {\bf TASK};\\
\x {\bf DCL} Temperature (Num\_Temp) {\bf FIXED}(15); \\
\x {\bf FOR} i {\bf TO} Num\_Temp\\
\x {\bf REPEAT}\\
\x \x Temperature(i) := Get\_Temp(i);\\
\x {\bf END};\\
\x ! Processing the measured values\\
\x {\bf WRITE} Temperature {\bf TO} Logbook; \\
\x {\bf END}; ! Measurement
\end{enumerate}

The general forms of the read and write statements read:

ReadStatement ::= \\
\x {\bf READ} [ \{ Name$\S $Variable $\mid$ Segment \} [ , \{ Name$\S $Variable $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ;

WriteStatement ::=\\
\x {\bf WRITE} [ \{ Expression $\mid$ Segment \} [ , \{ Expression $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ;

Segment ::= \\
\x Name$\S $Field ( [ Index , ] $^{...}$ Index : Index)

Index ::=\\
\x Expression$\S $WithIntegerAsValue

Position ::= \\
\x AbsolutePosition $\mid$ RelativePosition $\mid$ {\bf RST} (Name$\S $ErrorVariable-FIXED)

AbsolutePosition ::=\\
\x \{ {\bf COL $\mid$ LINE} \} (Expression) $\mid$\\
\x {\bf POS} ( [ [ Expression , ] Expression , ] Expression) $\mid$ \\
\x {\bf SOP} ( [ [ Name , ] Name , ] Name)

RelativePosition ::=\\
\x \{ {\bf X $\mid$ SKIP $\mid$ PAGE} \} [ (Expression) ] $\mid$ \\
\x {\bf ADV} ( [ [ Expression , ] Expression , ] Expression )

Upon entry with the read statement, the addressed data elements are
read one after the other and correspondingly assigned to the variables
in the variable list. The variables are assigned according to the
general rules for assignments. If an element of the variable list is an
array, the addressed data are assigned by rows; if it is a structure, the
data are assigned to the structure components in the order determined by
the structure declaration.

For simplicity in writing, the elements (of the last dimension) of an
array following one another in the variable list can be declared in form
of a segment. Let list be an array with ten elements list(1), ... ,
list(10); then the two following statements are equivalent:

{\bf READ} list(2), list(3), list(4) ... ;\\
{\bf READ} list (2 : 4), ... ;

All position expressions are completely evaluated, before values are
assigned to the data elements.

Example:

Read X from position 3 and Y from position 5 from the dation file:

{\bf READ} X {\bf FROM} File {\bf BY POS}(3) ;\\
{\bf READ} Y {\bf FROM} File {\bf BY POS}(5) ;

The execution of the statement

{\bf READ} X, Y {\bf FROM} File {\bf BY POS}(3), {\bf POS}(5) ;

however, results in that X being read from position 5 and Y from the
subsequent position.

The RST attribute (cf. \ref{sec_dation_rst}) can occur anywhere in the
 position list.
However, it does not become effective until it is evaluated. A position
list is elaborated one after the other, starting from the left. If an
error occurs, the elaboration of the I/O statement is aborted in this
position, and the error reaction valid at this moment (error assignment
to an RST variable or system reaction) is executed.

These statements analogously hold for the write statement.

The type of the variables in the variable list of the read statement
must be compatible with the class attribute of the given data station;
this holds analogously for the results of the expressions in the
expression list of the write statement.

The variable or expression list of the read or write statement may be
lacking, if these statements shall only be used for positioning in the
denoted data stations. In this case, however, a position must be
given.

The values in the position list refer to the structure of the data
station and determine the data elements to be transmitted. Thus, the
values of the expressions must be of type FIXED and must be compatible
with the structure.

When using an absolute position, i.e., a position independent from the
actual data element, the data station must have the access attribute
DIRECT. A relative position denotes the distance of the data element to
be transmitted from the current data element; in this case, the data
station must have the access attribute FORWARD, FORBACK or DIRECT.

In detail, the possible position attributes have the following
meanings:
\begin{itemize}
\item COL (Expression)\\
refers to the first dimension (from the right) of the structure and
determines the i-th element in the current line of the data station, if
i equals the value of the expression.
\item LINE (Expression)\\
refers to the second dimension of the structure and determines the i-th
line of the current page of the data station, if i equals the value of
the expression.

Example:

A 2-dimensional array corresponds to the structure (5,10):

\setlength{\unitlength}{0.00087500in}%
\begin{picture}(5627,2781)(179,-2206)
\thicklines
\put(451,-1861){\framebox(4500,2250){}}
\thinlines
%\multiput(1891,-61)(-5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(1891,-61){\line(-1,-1){90}}
\put(1981,-61){\line(-1,-1){180}}
\put(2071,-61){\line(-1,-1){270}}
\put(2161,-61){\line(-1,-1){360}}
\put(2251,-61){\line(-1,-1){450}}
\put(2251,-151){\line(-1,-1){360}}
\put(2251,-241){\line(-1,-1){270}}
\put(2251,-331){\line(-1,-1){180}}
%\multiput(2251,-421)(-5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(2251,-421){\line(-1,-1){90}}
\put(1801,-61){\line( 1,-1){450}}
\put(1891,-61){\line( 1,-1){360}}
\put(1981,-61){\line( 1,-1){270}}
\put(2071,-61){\line( 1,-1){180}}
%\multiput(2161,-61)(5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(2161,-61){\line( 1,-1){90}}
\put(1801,-421){\line( 1,-1){90}}
\put(1801,-151){\line( 1,-1){360}}
\put(1801,-241){\line( 1,-1){270}}
\put(1801,-331){\line( 1,-1){180}}
%\multiput(1801,-421)(5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(1801,389){\line( 0,-1){2250}}
\put(2251,389){\line( 0,-1){2250}}
\put(451,-61){\line( 1, 0){4500}}
\put(451,-511){\line( 1, 0){4500}}
\put(676,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}1}}}
\put(1126,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}2}}}
\put(1576,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}3}}}
\put(2026,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}4}}}
\put(2476,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}5}}}
\put(2926,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}6}}}
\put(3376,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}7}}}
\put(3826,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}8}}}
\put(4276,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}9}}}
\put(4726,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}10}}}
\put(226,-1726){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}5}}}
\put(2026,-2176){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}COL(4)}}}
\put(5491,-376){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}LINE(2)}}}
\put(226,-331){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}2}}}
\put(226,119){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}1}}}
\put(226,-781){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}3}}}
\put(226,-1231){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}4}}}
\end{picture}

\item POS ( [ [ Expression$\S $Page , ] Expression$\S $Row , ] Expression$\S $Column )\\
gives the position of a data element in the n-dimensional structure
(n = 1, 2, 3) of a data station. Lacking expressions are replaced by the
respective current value.

Example:

With the statement

{\bf READ} x {\bf FROM} File1 {\bf BY POS}(3,2,8);

the eighth data element of the second row of the third page of File1 is
read into x. If this is followed by the statement

{\bf READ} x {\bf FROM} File1 {\bf BY POS}(4,5);

the fifth data element of the fourth row of the third page of File1 is
read into x.
\item SOP ( [ [ Name$\S $Page , ] Name$\S $Row , ] Name$\S $Column )\\
is the counterpart to POS. With SOP, the current positions of a dation
can be assigned to the given program variables. The number of names in
SOP may not exceed the number of dimensions in the addressed dation.
\end{itemize}

In the following, let i be the value of the respective expression.
\begin{itemize}
\item X [ (Expression) ]\\
refers to the first dimension of the structure and determines the i-th
element behind (i positive) or before (i negative), respectively, the
current element in the current row of the data station; i = 0 denotes
the current element.
\item SKIP [ (Expression) ]\\
refers to the second dimension of the structure and determines the start
(the first element) of the i-th row behind (i positive) or before (i
negative), respectively, the current row of the current page of the data
station; i = 0 denotes the current row.
\item PAGE [ (Expression) ]\\
refers to the third dimension of the structure and determines the start
of the i-th page behind (i positive) or before (i negative),
respectively, the current page of the data station; i = 0 denotes the
current page.
\end{itemize}

If the Expression denotation is not present for X, SKIP, or PAGE, respectively,
value 1 is assumed. The value of a given expression must be positive, if
the data station has the attribute FORWARD.
\begin{itemize}
\item ADV ( [ [ Expression$\S $Page , ] Expression$\S $Row , ] Expression$\S $Column )\\
gives the distance of the data element to be transmitted from the
current data element. Missing expressions are replaced by the value
zero. If the data station has the attribute FORWARD, the value for the
expression furthest to the left must be positive or zero.
\end{itemize}

Examples:

Let the corresponding data station File1 have the structure (10, 10,
10), let the actual position be (5,3,8).

\begin{tabular}{l@{\x}l@{\x}l}
position statement   & new position &     \\ \hline
X                    & (5,3,9)      &     \\
X (-5)               & (5,3,3)      &     \\
X (4)                & (5,4,2)      & (1) \\
SKIP (2)             & (5,5,1)      &     \\
SKIP (-1)            & (5,2,1)      &     \\
PAGE                 & (6,1,1)      &     \\
PAGE (6)             & (1,1,1)      & (2) \\
PAGE (-4)            & (1,1,1)      &     \\
ADV (2,5,1)          & (7,8,9)      &     \\
ADV (1,0)            & (5,4,8)      &     \\
ADV (-3,-2,1)        & (2,1,9)      &     \\
ADV (1,8,0)          & (7,1,8)      & (3)
\end{tabular}

With a relative positioning, dimension boundaries may not be exceeded
(cf. the marked examples), unless the data station possesses the access
attribute STREAM or CYCLIC, respectively. STREAM allows to exceed the
internal dimension boundary (examples (1) and (3)), but not to exceed
the boundary of the highest dimension (example (2)). For this, a data
station must possess the attribute CYCLIC. If error reactions shall
occur upon exceeding the corresponding boundaries, the attributes
NOSTREAM or NOCYCL, respectively, must be given. By default, STREAM and
NOCYCL are assumed.

Example:

{\bf DCL} File1 {\bf DATION INOUT FIXED DIM}(10,10,10) {\bf FORWARD CYCLIC}\\
\x {\bf GLOBAL CREATED}(Disk);

Let each time the current position be (5,3,8). Then it holds:

\begin{tabular}{l@{\x}l}
position statement   & new position \\ \hline
X (6)                & (5,4,4)      \\
SKIP (8)             & (6,1,1)      \\
PAGE (7)             & (2,1,1)      \\
ADV (9,0,3)          & (4,4,1)
\end{tabular}

\begin{added}
The positioning controls work diffently on {\bf FORWARD} and {\bf DIRECT}
dations. FORWARD dations does not allow to adjust the real position for read
and write directly. 
Thus the positioning discards input data in the READ statement and 
writes as may zero bytes as required to fill the amount of data elements
in the WRITE statements.
\end{added}

\begin{added}
For dation with the ClassAttribute {\bf ALL} only 1 unlimited dimension
DIM(*) is supported in OpenPEARL.
Absolute positioning is allowed only to POS(1) for DIRECT dations.
No relative positioning is allowed.
\end{added}

\section{The Get and Put Statements (GET, PUT)}    % 10.5
\label{sec_get_put}

The get statement serves for the input, the put statement for the
output of data with conversion between computer internal and external,
character oriented representations on ALPHIC data stations. To control
this conversion, formats can be declared.

Examples:

\begin{enumerate}
\item The following text is to appear on the monitor of a storekeeper:

\begin{verbatim}
___article no:__4711
___stock:_______1281
\end{verbatim}

Program steps required:

...\\
{\bf SPC} monitor {\bf DATION INOUT ALPHIC};\\
{\bf DCL} stock\_monitor {\bf DATION INOUT ALPHIC DIM}($^*$,20,80)\\
\x {\bf FORWARD GLOBAL CREATED} (monitor);\\
{\bf DCL} (artno, stock) {\bf FIXED};\\
...\\
{\bf PUT} 'article no:', artno, 'stock:', stock {\bf TO} stock\_monitor\\
\x {\bf BY X}(3), {\bf A}(13), {\bf F}(4), {\bf SKIP}, {\bf X}(3), {\bf A}(13), {\bf F}(4);\\
...

\item Output of two values in standard format on a new page of the
printer.

...\\
{\bf SPC} thermo\_print {\bf DATION OUT ALPHIC};\\
{\bf DCL} printer {\bf DATION OUT ALPHIC DIM}($^*$,50,120) {\bf FORWARD}\\
\x {\bf GLOBAL CREATED} (thermo\_print);\\
{\bf DCL} a {\bf FIXED}(15), x {\bf FLOAT}(31);\\
...\\
a := 5;\\
x := 2.33;\\
...\\
{\bf PUT TO} printer {\bf BY PAGE};\\
{\bf PUT} a, x {\bf TO} printer {\bf BY LIST};

The execution results in the following printer layout:

\begin{verbatim}
_____5___2.33000E+00
\end{verbatim}
\item Let data be stored in an input file on floppy disk in the
following form:

\begin{tabular}{l@{:}l}
column  1 -- 10 & article identifier (CHARACTER)\\
column 12 -- 20 & quantity (FIXED)\\
column 22 -- 30 & price per unit right-justified (e.g., \_\_\_124.57)
\end{tabular}

They are to be read into the variables article\_id, quantity, price:

...\\
{\bf SPC} floppy\_disk {\bf DATION INOUT ALL};\\
{\bf DCL} input\_file {\bf DATION IN ALPHIC DIM}($^*$,80) {\bf TFU FORWARD}\\
\x \x {\bf GLOBAL CREATED} (floppy\_disk),\\
\x article\_id {\bf CHAR}(10),\\
\x quantity {\bf FIXED},\\
\x price {\bf FLOAT};\\
...\\
{\bf GET} article\_id, quantity, price {\bf FROM} input\_file {\bf BY}\\
\x {\bf A}(10), {\bf X}, {\bf F}(9), {\bf X}, {\bf E}(9), {\bf SKIP};
\end{enumerate}

The general forms of the get and put statements read:

GetStatement ::=\\
\x {\bf GET} [ \{ Name$\S $Variable $\mid$ Segment \} [ , \{ Name$\S $Variable $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} FormatPosition [ , FormatPosition ] $^{...}$ ] ;

PutStatement ::=\\
\x {\bf PUT} [ \{ Expression $\mid$ Segment \} [ , \{ Expression $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} FormatPosition [ , FormatPosition ] $^{...}$ ] ;

FormatPosition ::=\\
\x [ Factor ] \{ Format $\mid$ Position \} $\mid$\\
\x Factor ( FormatPosition [ , FormatPosition ] $^{...}$ )

Factor ::=\\
\x ( Expression$\S $IntegerGreaterZero ) $\mid$ IntegerWithoutPrecision$\S $GreaterZero

Format ::=\\
\x FixedFormat $\mid$ FloatFormat $\mid$ CharacterStringFormats $\mid$ BitFormat $\mid$\\
\x TimeFormat $\mid$ DurationFormat $\mid$ ListFormat $\mid$ R-Format $\mid$ {\bf RST} (Name)

Upon input with the get statement, the addressed data elements are
read one after the other and correspondingly assigned to the variables
in the variable list (analogously to the read statement). The
assignment to the variables takes place according to the general
assignment rules.

The input is terminated, when the the variable list is worked off. If
there still are list elements, but no data elements, an error message is
displayed.

When executing the put statement, the values of the expressions
following PUT in the list are written out in the given order.

In the order of notation, a format in the format position list is
associated with each variable in the variable list of the get
statement, describing the external representation of the data on the
named data station and used for converting into computer internal
representation. The kind of format is determined by the type of the
variable. Besides formats, the list of the format positions can also
contain position statements (cf. \ref{sec_read_write})
for positioning in the data
station. If the variable list is not exhausted, yet, the further
positionings are executed and the just mentioned association is
continued with the next following format. If, on the contrary, the
variable list is already exhausted, the following position attributes
are elaborated, until a format is encountered or the list is worked off.

If the variable list contains an array or a segment, the following
formats are associated with the array elements one after the other.

The number of the transmitted data elements is only determined by the
variable list, not by the format position list. If there are more
formats than variables, the surplus formats are neglected. If there are
still variables left, when the format position list is worked off, it is
re-started with the first element of the format position list. In each
case, the transmission is terminated, when the variable list is
exhausted.

The above analogously holds for the put statement with ``variable''
replaced by ``expression''.

The data station must possess the class attribute ALPHIC, a structure,
and an access attribute. The selection of the access attribute possibly
limits the positioning possibilities (cf. \ref{sec_read_write}).

The format position list consists of format and position statements.
To simplify notation, repetition factors may be used in the list. For
instance, the format position list

X(2), F(12,3), X(2), F(12,3), X(2), F(12,3)

can be written in an easier way:

(3) (X(2), F(12,3))

The following table shows the permitted associations between formats and
types of the data elements to be transferred:

\begin{tabular}{ll}
format                  & data type \\ \hline
fixed format            & FIXED, FLOAT \\
float format            & FIXED, FLOAT \\
bit format              & BIT          \\
character string format & CHARACTER    \\
time format             & CLOCK        \\
duration format         & DURATION     \\
list format             & all given data types
\end{tabular}

In detail, the formats have the following forms and meanings (the
position statements were explained in \ref{sec_read_write}).

\begin{added}
The positioning controls work diffently on {\bf FORWARD} and {\bf DIRECT}
dations. FORWARD dations does not allow to adjust the real position for read
and write directly. 
Thus the positioning discards input data in the GET statement and 
writes as may space characters as required to fill the amount of data elements
in the PUT statements.
\end{added}


\subsection{The Fixed Format (F)}   % 10.5.1
\label{sec_dation_f_format}

FixedFormat ::=\\
\x {\bf F} (FieldWidth [ , DecimalPositions [ , ScaleFactor ] ] )

FieldWidth ::=\\
\x Expression$\S $WithPositiveIntegerAsValue

DecimalPositions ::=\\
\x Expression$\S $WithNonNegativeIntegerAsValue

ScaleFactor ::=\\
\x Expression$\S $WithIntegerAsValue

The fixed format describes the external representation of decimal fixed
point numbers. The field width w is the complete number of characters
available for the decimal number; decimal positions d denote the number
of digits behind the decimal point. The scale factor p can be both
positive or negative; it causes that not the number itself, but its
value multiplied by 10$^{**}$p is transferred.

It is important that only integers can be transferred with the fixed
format, but also the processing of fractional fixed point numbers is
possible by scaling. These are converted to integers upon input and to
fractional numbers again upon output.

\begin{removed}
\begin{enumerate}
\item {\bf Output}
\begin{enumerate}
\item The decimal number is stored right-justified in a field of length
w in the form

[ - ] pi [ . pi ]

where pi means positive integer. If the number does not occupy the
entire field, the left part is padded with spaces.
\item If 0 $>$ d or w $<$ d, the character $^*$ is stored w times.
\item In case w $\leq$ 0, no character is stored; an error is reported.
\item If d = 0 or is not given, only the integer part of the decimal
number rounded without decimal point is written out.
\item Except for the zero immediately in front of the decimal point,
leading zeros are suppressed.
\end{enumerate}
\item {\bf Input}
\begin{enumerate}
\item A field of length w is read, containing a decimal fixed point
number in the following representation:

[ [ + $\mid$ - ] pi [ . [ pi ] ] ]

\item Spaces preceding or following the number are ignored.
\item If the entire field is empty, value 0 is read in.
\item If no decimal point occurs in the representation, the last d
digits are interpreted as positions following a decimal point. It must
be p $\geq$ d.
\item If a decimal point occurs in front of the last b digits in the
representation, then it has priority over the specification by d. In
this case, the statement of d has no meaning. It must be p$\geq$ b.
\item If w $\leq$ 0, no assignment takes place; an error is reported.
\end{enumerate}
\end{enumerate}

Example:

\begin{tabular}{lll}
value  & format   & output \\ \hline
13.5   & F(7,2)   & \_\_13.50  \\
275.2  & F(4,1)   & $^{****}$ \x \x error message! \\
22.8   & F(5)     & \_\_\_23 \\
212.73 & F(9,2,2) & \_21273.00 \\
212.73 & F(9,2)   & \_\_\_212.73
\end{tabular}
\end{removed}

\begin{added}
\begin{enumerate}
\item {\bf Output}
\begin{enumerate}
\item The decimal number is stored right-justified in a field of length
w in the form

[ - ] pi [ . pi ]

where pi means positive integer. If the number does not occupy the
entire field, the left part is padded with spaces.
\item If 0 $>$ d or w $<$ d, the FixedFormatSignal is induced
\item In case w $\leq$ 0, the FixedFormatSignal is induced
\item If d = 0 or is not given, only the integer part of the decimal
number rounded without decimal point is written out.
\item Except for the zero immediately in front of the decimal point,
leading zeros are suppressed.
\item if the output value does not fit into the given field width 
   (also regarding p), the FixedValueSignal is induced.
\end{enumerate}
\item {\bf Input}
\begin{enumerate}
\item A field of length w is read, containing a decimal fixed point
number in the following representation:

[ [ + $\mid$ - ] pi [ . [ pi ] ] ]

\item Spaces preceding or following the number are ignored.
\item If the entire field is empty, value 0 is read in.
\item If no decimal point occurs in the representation, the last d
digits are interpreted as positions following a decimal point. It must
be p $\geq$ d.
\item If a decimal point occurs in front of the last b digits in the
representation, then it has priority over the specification by d. In
this case, the statement of d has no meaning. It must be p$\geq$ b.
\item If w $\leq$ 0, no assignment takes place;
    the FixedFormatSignal is induced
\item If d $<$ 0 or w $<$ d, no assignmant happens and 
    the FixedFormatSignal is induced
\item If the data in the input field does not match a valid fixed 
   number, the FixedValueSignal is induced
\end{enumerate}
\end{enumerate}

Example:

\begin{tabular}{lll}
value  & format   & output \\ \hline
13.5   & F(7,-1)   &  \x \x {\em FixedFormatSignal!}  \\
13.5   & F(0)   &  \x \x {\em FixedFormatSignal!}  \\
13.5   & F(7,2)   & \_\_13.50  \\
-13.5   & F(7,2)   & \_-13.50  \\
275.2  & F(4,1)   &  \x \x {\em FixedValueSignal!} \\
22.8   & F(5)     & \_\_\_23 \\
212.73 & F(9,2,2) & \_21273.00 \\
212.73 & F(9,2)   & \_\_\_212.73
\end{tabular}
\end{added}

\subsection{The Float Format (E)}   % 10.5.2
\label{sec_dation_e_format}

\begin{removed}
FloatFormat ::=\\
\x {\bf E} (FieldWidth [ , DecimalPositions [ , Significance ] ] )
\end{removed}
\begin{added}
FloatFormat ::=\\
\x {\bf E}[3] (FieldWidth [ , DecimalPositions [ , Significance ] ] )
\end{added}

Significance ::= \\
\x Expression$\S $WithIntegerAsValue

The float format describes the external representation of decimal
floating point numbers of the form

[ + $\mid$ - ] FloatingPointNumber

where the exponent consists of two \addedtext{(E) or three (E3)} digits.
 Field width and decimal
positions have the same meaning as in the fixed format; significance s
denotes the number of significant digits; i.e., the length of the
mantissa.

E(w,d) is of equivalent to E(w,d,d+1), and E(w) to E(w,0).

\begin{removed}
\begin{enumerate}
\item {\bf Output}\\
The floating point number is stored right-justified in a field of length
w. Otherwise, 1(a) in \ref{sec_dation_f_format} holds.

If 0 $<$ w $<$ d, an error reaction takes place.

In case 0 $<$ w $>$ d $>$ s, the mantissa is chosen so that it holds:

\hspace*{1cm}$10^{s-d-1} \leq \mid$ mantissa $\mid < 10^{s-d}$

For w = 0, no character is stored; the respective expression in the
expression list is skipped.

If d $>$ 0, the number has the form

\hspace*{1cm}[ - ] s-d digits . d digits E \{ + $\mid$ - \} exponent.

The exponent is determined in such a way that the leading digit of the
mantissa does not equal zero, if the number is different from zero.

If d = 0, the number has the form

\hspace*{1cm}[ - ] s digits E \{ + $\mid$ - \} exponent

If w is too small to mention a digit of the mantissa, the character $^*$
is written out w times, followed by an error reaction.
\item {\bf Input}\\
A field of length w is read, containing a decimal floating point number
in one of the possible representations (cf. 5.3).

The statements 2(b) to 2(f) in \ref{sec_dation_f_format} hold analogously.
\end{enumerate}

\begin{tabular}{lll}
value  & format    & output \\ \hline
-0.07  & E(9,1)    & \_-7.0E-02 \\
2713.5 & E(11,2,4) & \_\_27.13E+02 \\
2721   & E(8)      & \_\_\_2E+03
\end{tabular}
\end{removed}

\begin{added}
\begin{enumerate}
\item {\bf Output}\\
\begin{enumerate}
\item If 0 $<$ w $<$ d, the FloatFormatSignal is induced. 

\item For w $<=$ 0, the FloatFormatSignal is induced.

\item If w is too small to mention a digit of the mantissa, the FloatValueSignal is induced

\item The floating point number is stored right-justified in a field of length
w. Otherwise, 1(a) in \ref{sec_dation_f_format} holds.

\item In case w $>$ d $>$ s, the mantissa is chosen so that it holds:

\hspace*{1cm}$10^{s-d-1} \leq \mid$ mantissa $\mid < 10^{s-d}$

\item If d $>$ 0, the number has the form

\hspace*{1cm}[ - ] s-d digits . d digits E \{ + $\mid$ - \} exponent.

The exponent is determined in such a way that the leading digit of the
mantissa does not equal zero, if the number is different from zero.

\item If d = 0, the number has the form

\hspace*{1cm}[ - ] s digits E \{ + $\mid$ - \} exponent

\item the exponent field used two digits in E-format and 
      three digit in E3-format

\end{enumerate}
 
\item {\bf Input}\\
\begin{enumerate}
\item A field of length w is read,
    containing a decimal floating point number
    in one of the possible representations (cf. 5.3).

%\item The statements 2(b) to 2(f) in \ref{sec_dation_f_format}
%     hold analogously.
\item If w $<=$ 0, or d $<$ 0, or s $<$ 0, no assignment happens and  
         the FloatFormatSignal is induced
\item If the data in the field does not match a valid number, 
 no data is assigned and the FloatValueSignal is induced.
\end{enumerate}
\end{enumerate}

\begin{tabular}{lll}
value  & format    & output \\ \hline
-0.07  & E(9,1)    & \_-7.0E-02 \\
2713.5 & E(11,2,4) & \_\_27.13E+02 \\
2721   & E(8)      & \_\_\_2E+03 \\
2721   & E3(8)      & \_\_2E+003
\end{tabular}
\end{added}

\subsection{The Character String Formats (A) and (S)}  % 10.5.3
\label{sec_dation_a_format}

CharacterStringFormat ::=\\
\x {\bf A} [ (Expression$\S $NumberCharacters) ] $\mid$ {\bf S} (Name$\S $NumberCharactersVariableFixed)

The character formats describe the external representation of character
strings (character quantities) of the form

Character$^{...}$

\subsubsection{Character String Format (A)}

The value of the expression in character string format means the total
number w of the character positions available for the representation.
\begin{enumerate}
\item {\bf Output}\\
If the format has form ``A (Expression)'', the character string is
written out left-justified in the above presented form in a field of
length w. If the character string consists of more than w characters, it
is truncated on the right; if it consists of less than w characters, the
field is padded with spaces on the right. 
\begin{removed}
If w = 0, no characters are
written out, and the expression in the expression list of the put
statement is skipped.
\end{removed}
\begin{added}
If w $<=$ 0, the CharacterFormatSignal is induced
\end{added}

If the expression is not given in the format, i.e., the format has the
form ``A'', the string is written out in a field, whose length equals
the string length.
\item {\bf Input}\\
Characters up to the maximum of w or until encountering the next record
delimiter (e.g., CR) are read in. A record delimiter is not transferred
into the character string variable.

If w is smaller than length lg of the associated character string
variable, the right part is padded with spaces; in case w $>$ lg, the
right part is truncated.
\begin{removed}
 If w = 0, a string of lg spaces is assigned to
the variable.
\end{removed}
\begin{added}
 If w $<=$ 0, no assignment happens and the CharacterFormatSignal is 
   induced. 
\end{added}
\end{enumerate}

Examples:

The output of the character string 'PEARL' in format

\begin{itemize}
\item A    results in PEARL 
\item A(5) results in PEARL 
\item A(7) results in PEARL\_\_ 
\item A(2) results in PE
\end{itemize}

The input of the character string 'PEARL\_\_' to a CHAR(5) variable text in
format

\begin{itemize}
\item A is equivalent to text := 'PEARL';
\item A(5) is equivalent to text := 'PEARL';
\item A(7) is equivalent to text := 'PEARL';
\item A(2) is equivalent to text := 'PE\_\_\_';
\end{itemize}

\subsubsection{Character String Format (S)}

The variable in character string format must be of type FIXED.
\begin{enumerate}
\item {\bf Output}\\
Identical with A format: the value of the given variable determines the
width of the output field.
\item{\bf Input}\\
Characters up to the maximum lg (length of the associated character
string variables) or until encountering the next record delimiter are
read in; otherwise, the same rules like for the A format hold.
Additionally, the number of characters (without record delimiter) read
is assigned to the variable of the S format. Which record delimiters are
defined for which devices is to be found in the respective PEARL user
manual.
\end{enumerate}

Example:

Command lines are to be read in from the terminal.

{\bf DCL} buffer {\bf CHAR}(80);\\
{\bf DCL} length {\bf FIXED};\\
...\\
{\bf GET} buffer {\bf FROM} terminal {\bf BY S}(length);\\
...

After the entry ``abc$<$RETURN$>$'' on the keyboard (the key
$<$RETURN$>$ creates a record delimiter), the variable ``buffer''
contains the characters ``abc'' and the variable ``length'' the value 3.

\subsection{The Bit Format (B)}    % 10.5.4
\label{sec_dation_b_format}

BitFormat ::=\\
\x \{ {\bf B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4} \} [ ( Expression$\S $NumberCharacters) ]

The bit format describes the external representation of bit strings (bit
quantities), namely (cf. 5.4)
\begin{itemize}
\item in binary form by the format: \{ B $\mid$ B1 \} [ ( Expression ) ] ,
\item in form of tetrades by the format: B2 [ ( Expression ) ] ,
\item in form of octades by the format: B3 [ ( Expression ) ] ,
\item in hexadecimal form by the format: B4 [ ( Expression ) ] .
\end{itemize}

The value of the expression in bit format means the total number w of
the character positions available for the representation.
\begin{enumerate}
\item {\bf Output}\\
If the expression is declared in the format, the bit string is written
out left-justified in the above represented form in a field of length
w. If the bit string consists of more than w characters, it is truncated
on the right; if it consists of less than w characters, the field is
padded with zeros on the right. If w is not given, and if the bit format
thus has the form B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4, the string
is written out in a field, whose length equals the length of the
string.

\begin{added}
If w $<=$ 0, no data is written and the BitFormatSignal is induced.
\end{added}

\item {\bf Input}\\
The expression must be given.

A field of length w is read in, which must contain a bit string of the
above described form. The field must not exclusively consist of spaces.
Spaces preceding or following the string are ignored. The statements on
the input with the A format hold likewise.

\begin{added}
If w $<=$ 0, no data is assigned and the BitFormatSignal is induced.

If the data field does not match a valid bit representation, the
BitValueSignal is induced.
\end{added}
\end{enumerate}

Example:

The output of the bit string '0101110' in the format

\begin{itemize}
\item B(5) results in 01011 
\item B2(3) results in 113 
\item B3(3) results in 270 
\item B4(2) results in 5C
\end{itemize}

Let the variable bit string be of type BIT(8); the input, there are the
following possibilities:

\begin{tabular}{lll}
data element to be entered & format & value of bit string \\ \hline
11111                      & B(5)   &         11111000    \\
201                        & B2(3)  &         10000100    \\
235                        & B3(3)  &         01001110    \\
AB                         & B4(2)  &         10101011
\end{tabular}

\subsection{The Time Format (T)}   % 10.5.5
\label{sec_dation_t_format}

TimeFormat ::= \\
\x {\bf T} ( FieldWidth [ , DecimalPosition ] )

The time format describes the external representation of time data. The
field width means the total number w of the character positions
available for the representation; decimal positions stands for the
number d of the digits for the fractional parts of seconds of the clock
time.
\begin{enumerate}
\item {\bf Output}\\
\begin{added}
If w $<=$ 0 or d $<$ 0, no data is written an the ClockFormatSignal
   is induced.

If w is too small for the given clock value, the ClockValueSignal
   is induced.
\end{added}

The time is written out right-justified in a field of length w in the
form

[ Digit ] Digit : Digit Digit : Digit Digit [ . pi ]

If the first digit is zero, it is replaced by spaces. In case d = 0,
decimal point and fractional parts of seconds are not written out.

If the output value does not occupy the entire field, the left part is
padded up with spaces.
\item {\bf Input}\\
A field of length w is read in, which must contain a time in a permitted
representation (see 1). Preceding and following spaces are ignored.

\begin{added}
If w $<=$ 0 or d $<$ 0, no data is read and the ClockFormatSignal
   is induced.

If the input field does not match a valid clock constant, the 
   ClockValueSignal is induced.
\end{added}
\end{enumerate}

Examples:

\begin{tabular}{lll}
value               & format  & output \\ \hline
12.30 hours 5.2 sec & T(12,1) & \_\_12:30:05.2 \\
8 hours             & T(8)    & \_8:00:00
\end{tabular}

\subsection{The Duration Format (D)}   % 10.5.6
\label{sec_dation_d_format}

DurationFormat ::=\\
\x {\bf D} ( FieldWidth [ , DecimalPosition ] )

The duration format describes the external representation of durations.
The value of the field width means the total number w of the character
positions available for representation, the value of decimal positions
means the number d of the digits for the fractional parts of seconds of
the duration.
\begin{enumerate}
\item {\bf Output}\\
The duration is written out right-justified in a field of length w in
the form

[ Digit ] Digit\_HRS\_Digit Digit\_MIN\_Digit Digit [ . pi ]\_SEC

\begin{added}
If w $<=$ 0 or d $<$ 0, no data is written an the ClockFormatSignal
   is induced.

If w is too small for the given clock value, the ClockValueSignal
   is induced.
\end{added}

\begin{removed}
The rules from \ref{sec_dation_t_format} (1) are valid.
\end{removed}
\item {\bf Input}\\
If w $<=$ 0 or d $<$ 0, no data is read and the DurationFormatSignal
   is induced.

\begin{added}
A field of length w is read in, which must contain a duration in a
permitted representation (see 1). Preceding and following spaces are
ignored.

If the input field does not match a valid clock constant, the 
   ClockValueSignal is induced.
\end{added}
\end{enumerate}

Examples:

\begin{tabular}{lll}
value               & format  & output \\ \hline
11 hours 15 minutes & D(20)   & 11\_HRS\_15\_MIN\_00\_SEC \\
100 milliseconds    & D(24,3) & \_0\_HRS\_00\_MIN\_00.100\_SEC
\end{tabular}

The character \_ means a space.

\subsection{The List Format (LIST)}    % 10.5.7
\label{sec_dation_list_format}

ListFormat ::=\\
\x {\bf LIST}

The list format serves for the input/output of fixed, float, bit, char,
clock, and dur quantities.
\begin{enumerate}
\item {\bf Output}\\
Subsequent output data are separated by two spaces, each. The data are
written out in such a way, as if for a quantity of type

\begin{tabular}{lll}
CHAR(k)  & format & A(k)\\
BIT(k)   & format & B(k)\\
FIXED(k) & format & F(n)\\
FLOAT(k) & format & E(m,m-7,m-6)\\
CLOCK    & format & T(8)\\
DUR      & format & D(20)
\end{tabular}

with n = ENTIER(k/3.32) + 2, m = ENTIER (k/3.32) + 3 were
declared.
\item {\bf Input}\\
The input data can have any form permitted for the representation of
constants. They are separated by a comma or at least two spaces. If no
constant is between two commas, the corresponding element of the
variable list remains unchanged.
\end{enumerate}

Examples:

\begin{tabular}{llll}
data type & value    & implicit format & output \\ \hline
FIXED(15) & 127      & F(6)            & \_\_\_127 \\
FLOAT(31) & 3.28E+28 & E(12,5,6)       & \_3.28000E+28\\
BIT(8)    & 'EF'B4   & B(8)            & 11101111
\end{tabular}

\subsection{The R Format (R)}   % 10.5.8
\label{sec_dation_r_format}

Sometimes, the same format position lists are used in more than one get
or put statement. The R format serves to describe these lists only
once. For this, a list with the so-called format declaration is
introduced.

FormatDeclaration ::=\\
\x Identifier : {\bf FORMAT} ( FormatPosition [ , FormatPosition ] $^{...}$ ) ;

Example:

Ftab : {\bf FORMAT} ( {\bf X}(2), {\bf F}(8,3), (3) ( {\bf X}(2), {\bf E}(10,3) ) ) ;

A format declared in such a way can be used in a get or put statement,
stating its identifier:

R-Format ::=\\
\x {\bf R} ( Identifier$\S $Format )

When transmitting data, the R format is replaced by the format position
list contained in the indicated format declaration.

Example:

{\bf PUT} a, x, y, z {\bf TO} printer {\bf BY }(Ftab) ;

The format position list in the format declaration must not contain any
R format referring directly or indirectly (via another format
declaration) to its own format declaration.

\section{The Convert Statement (CONVERT)}   % 10.6
\label{sec_convert}

The comfortable conversion of number values in character strings and
vice versa is very important for many applications, e.g., for the
creation of display masks or for data exchange via communication
interfaces which cannot transfer binary data. The PUT and GET
statements enable that in connection with data stations. Following
that, the CONVERT statement is defined, performing formatted data
exchange with a character string or character string variable,
respectively, instead of a data station.

The general forms of the convert statement are:

ConvertToStatement ::=\\
\x {\bf CONVERT} Expression [ , Expression ] $^{...}$ {\bf TO} Name$\S $CharacterString\\
\x [ {\bf BY} FormatPositionConvert [ FormatPositionConvert ] $^{...}$ ] ;

ConvertFromStatement ::=\\
\x {\bf CONVERT} Name$\S $Variable [ , Name$\S $Variable ] $^{...}$ {\bf FROM}\\
Expression$\S $CharacterString\\
\x [ {\bf BY} FormatPositionConvert [ , FormatPositionConvert ] $^{...}$ ] ;

FormatPositionConvert ::=\\
\x [ Factor ] \{ Format $\mid$ PositionConvert \} $\mid$\\
\x Factor ( FormatPositionConvert [ , FormatPositionConvert ] $^{...}$ )

PositionConvert ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED ) $\mid$ {\bf X} ( Expression ) $\mid$ {\bf ADV} ( Expression ) $\mid$\\
\x {\bf POS} ( Expression ) $\mid$ {\bf SOP} ( Name$\S $PositionVariable-FIXED )

All permitted formats have the same meaning as for the PUT and GET
statements \addedtext{on FORWARD DATIONS}.
The only exception is the S format. In the convert
statement, the number of characters, which at this point in time was
read from Expression$\S $CharacterString or written into
Name$\S $CharacterString, respectively, is assigned to the variable in S
format.

Example:

\begin{tabbing}
{\bf DCL} (index, conv\_error, number\_of\_bytes) \= {\bf FIXED},\\
\x        value                                   \> {\bf FLOAT};\\
\end{tabbing}

{\bf DCL} string\_out {\bf CHAR}(40),\\
\x string\_in {\bf CHAR}(20);\\
...\\
{\bf CONVERT} 'Index =', index {\bf TO} string\_out {\bf BY A}, {\bf F}(4), {\bf S}(number\_of\_bytes);\\
{\bf CONVERT} index, value {\bf FROM} string\_in {\bf BY RST}(conv\_error), {\bf F}(4), {\bf E}(10,2);

\section{The Take and Send Statements}    % 10.7
\label{sec_take_send}

The take statement serves for the input, the send statement for the
output of data. These statements are provided for the transmission of
process data, and for the data exchange with user specific drivers,
respectively. The data station must possess the class attribute BASIC.

TakeStatement ::=\\
\x {\bf TAKE} [ Name$\S $Variable ] {\bf FROM} Name$\S $Dation\\
\x \x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;

SendStatement ::=\\
\x {\bf SEND} [ Expression ] {\bf TO} Name$\S $Dation\\
\x \x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;

RST-S-CTRL-Format ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf S} ( Name$\S $Variable-FIXED )\\
\x $\mid$ {\bf CONTROL} ( Expression [ , Expression [ , Expression ] ] )

The types of the ``variable'' in the take statement or the
``expression'' in the send statement, respectively, are implementation
dependent.

The attribute definitions RST, S and CONTROL may be stated in any
order, but only once, each. The meanings of the CONTROL and S formats
are implementation dependent and, thus, to be found in the respective
user manual of a PEARL implementation.

Example:

{\bf SYSTEM};\\
\x motor: DIGEA $^*$1$^*$1,4;

{\bf PROBLEM};\\
\x {\bf SPC} motor {\bf DATION OUT BASIC};\\
\x {\bf DCL} on {\bf INV BIT}(4) {\bf INIT}('1010'B1);

\x {\bf SEND} on {\bf TO} motor;

\section{Error Handling in I/O Statements (RST)}    % 10.8
\label{sec_dation_rst}

Usually, errors are recognised when the execution of I/O statements lead to the
termination of the responsible task, and an error message is written
out. This standard reaction of the PEARL system is suppressed by
defining

{\bf RST} ( Name$\S $ErrorVariable-FIXED )

in the parameter list of the OPEN/CLOSE statement, or as format or
position element in the other data transmission statements,
respectively.

``Name'' must denote a variable of type FIXED, in which an error number
not equal to zero is written in the case of error. Upon error free
execution of the I/O statement, the variable is set to zero. Possible
errors and their identification are to be found in the PEARL user manual
of the respective computer system.

The RST definition can be located in any position of the format or
position list of PUT, GET, WRITE, READ and CONVERT statements; also
multiple definitions with different variables are permitted. The RST
definition does not change the error reaction before the RST element is
evaluated in the format or position list. Upon recognition of an error,
the I/O statement is immediately aborted, and the error reaction valid
at this point in time (assignment of an error number to an RST variable
or the system reaction) is carried out.

\section{Interface for Additional Drivers}   % 10.9
\label{sec_driver_interface}

The diversity of --- particularly in the world of PCs --- existing I/O
controllers and devices does not allow the compiler supplier to account
for all I/O devices in the system part and create system names for them.
To be able to address special I/O devices from PEARL in spite of that
fact, a driver interface can be provided for certain operating systems,
to which the PEARL programmer himself can connect drivers. This
interface is described in the respective user manual (in the chapter
``Open Driver Interfaces'').

